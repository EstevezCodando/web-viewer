<!DOCTYPE html>
<html>
<head>
  <title>Pinch Zoom AR com Ancoragem</title>

  <script src="https://cdn.jsdelivr.net/gh/aframevr/aframe@1.6.0/dist/aframe-master.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>

  <style>
    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 20px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 1em 2em;
      border-radius: 10px;
      z-index: 10;
    }
  </style>
</head>
<body style="margin: 0; overflow: hidden;">
  <div id="loading">Carregando modelo...</div>

  <a-scene embedded arjs="sourceType: webcam; debugUIEnabled: true;">
    <a-marker id="marcador" type="pattern" url="pattern-hiro.patt">
      <a-entity
        id="modelo"
        gltf-model="https://estevezcodando.github.io/web-viewer/scene.glb"
        scale="0.01 0.01 0.01"
        position="0 0 0"
      ></a-entity>
    </a-marker>

    <a-entity camera></a-entity>
  </a-scene>

  <script>
    const modelo = document.querySelector('#modelo');
    const marcador = document.querySelector('#marcador');
    const loading = document.querySelector('#loading');

    let currentScale = 0.01;
    let initialDistance = null;
    let ancorado = false;

    // Esconde o loading quando o modelo estiver carregado
    modelo.addEventListener('model-loaded', () => {
      loading.style.display = 'none';
    });

    modelo.addEventListener('model-error', () => {
      loading.innerText = 'Erro ao carregar modelo.';
      loading.style.background = 'red';
    });

    // Ancoragem ao detectar o marcador
    marcador.addEventListener('markerFound', () => {
      if (ancorado) return; // Evita duplicação
      ancorado = true;

      // Espera o AR.js posicionar corretamente antes de ancorar
      setTimeout(() => {
        const worldPos = modelo.object3D.getWorldPosition(new THREE.Vector3());
        const worldRot = modelo.object3D.getWorldRotation(new THREE.Euler());

        // Cria nova entidade fixa
        const cena = document.querySelector('a-scene');
        const fixo = document.createElement('a-entity');
        fixo.setAttribute('gltf-model', modelo.getAttribute('gltf-model'));
        fixo.setAttribute('position', `${worldPos.x} ${worldPos.y} ${worldPos.z}`);
        fixo.setAttribute('rotation', `${THREE.Math.radToDeg(worldRot.x)} ${THREE.Math.radToDeg(worldRot.y)} ${THREE.Math.radToDeg(worldRot.z)}`);
        fixo.setAttribute('scale', `${currentScale} ${currentScale} ${currentScale}`);
        fixo.setAttribute('id', 'modelo');

        cena.appendChild(fixo);

        // Remove o marcador e o modelo original
        marcador.parentNode.removeChild(marcador);
      }, 500); // tempo para estabilizar o tracking
    });

    // Lógica para pinch-to-zoom
    document.addEventListener('touchmove', function (e) {
      const entidade = document.querySelector('#modelo');
      if (e.touches.length === 2 && entidade) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (!initialDistance) {
          initialDistance = distance;
        } else {
          const scaleChange = distance / initialDistance;
          let newScale = currentScale * scaleChange;

          newScale = Math.max(0.005, Math.min(0.05, newScale));
          entidade.setAttribute('scale', `${newScale} ${newScale} ${newScale}`);
        }
      }
    });

    document.addEventListener('touchend', function (e) {
      const entidade = document.querySelector('#modelo');
      if (e.touches.length < 2 && entidade) {
        currentScale = entidade.getAttribute('scale').x;
        initialDistance = null;
      }
    });
  </script>
</body>
</html>
